import { Component, Input, ChangeDetectorRef, ElementRef, NgZone } from '@angular/core';
/** A single degree in radians. */
var DEGREE_IN_RADIANS = Math.PI / 180;
/** Duration of the indeterminate animation. */
var DURATION_INDETERMINATE = 667;
/** Duration of the indeterminate animation. */
var DURATION_DETERMINATE = 225;
/** Start animation value of the indeterminate animation */
var startIndeterminate = 3;
/** End animation value of the indeterminate animation */
var endIndeterminate = 80;
/* Maximum angle for the arc. The angle can't be exactly 360, because the arc becomes hidden. */
var MAX_ANGLE = 359.99 / 100;
export var CircleProgress = (function () {
    function CircleProgress(_changeDetectorRef, _ngZone, _elementRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
        this._elementRef = _elementRef;
        /** The id of the last requested animation. */
        this._lastAnimationId = 0;
    }
    Object.defineProperty(CircleProgress.prototype, "value", {
        get: function () {
            return this._value;
        },
        set: function (v) {
            if (v != null) {
                var newValue = clamp(v);
                this._animateCircle((this.value || 0), newValue, linearEase, DURATION_DETERMINATE, 0);
                this._value = newValue;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CircleProgress.prototype, "interdeterminateInterval", {
        /** TODO: internal */
        get: function () {
            return this._interdeterminateInterval;
        },
        /** TODO: internal */
        set: function (interval) {
            clearInterval(this._interdeterminateInterval);
            this._interdeterminateInterval = interval;
        },
        enumerable: true,
        configurable: true
    });
    /**
       * Animates the circle from one percentage value to another.
       *
       * @param animateFrom The percentage of the circle filled starting the animation.
       * @param animateTo The percentage of the circle filled ending the animation.
       * @param ease The easing function to manage the pace of change in the animation.
       * @param duration The length of time to show the animation, in milliseconds.
       * @param rotation The starting angle of the circle fill, with 0Â° represented at the top center
       *    of the circle.
       */
    CircleProgress.prototype._animateCircle = function (animateFrom, animateTo, ease, duration, rotation) {
        var _this = this;
        var id = ++this._lastAnimationId;
        var startTime = Date.now();
        var changeInValue = animateTo - animateFrom;
        // No need to animate it if the values are the same
        if (animateTo === animateFrom) {
            this._renderArc(animateTo, rotation);
        }
        else {
            var animation_1 = function () {
                var elapsedTime = Math.max(0, Math.min(Date.now() - startTime, duration));
                _this._renderArc(ease(elapsedTime, animateFrom, changeInValue, duration), rotation);
                // Prevent overlapping animations by checking if a new animation has been called for and
                // if the animation has lasted longer than the animation duration.
                if (id === _this._lastAnimationId && elapsedTime < duration) {
                    requestAnimationFrame(animation_1);
                }
            };
            // Run the animation outside of Angular's zone, in order to avoid
            // hitting ZoneJS and change detection on each frame.
            this._ngZone.runOutsideAngular(animation_1);
        }
    };
    /**
     * Starts the indeterminate animation interval, if it is not already running.
     */
    CircleProgress.prototype._startIndeterminateAnimation = function () {
        var _this = this;
        var rotationStartPoint = 0;
        var start = startIndeterminate;
        var end = endIndeterminate;
        var duration = DURATION_INDETERMINATE;
        var animate = function () {
            _this._animateCircle(start, end, materialEase, duration, rotationStartPoint);
            // Prevent rotation from reaching Number.MAX_SAFE_INTEGER.
            rotationStartPoint = (rotationStartPoint + end) % 100;
            var temp = start;
            start = -end;
            end = -temp;
        };
        if (!this.interdeterminateInterval) {
            this._ngZone.runOutsideAngular(function () {
                _this.interdeterminateInterval = window.setInterval(animate, duration + 50, 0, false);
                animate();
            });
        }
    };
    /**
     * Removes interval, ending the animation.
     */
    CircleProgress.prototype._cleanupIndeterminateAnimation = function () {
        this.interdeterminateInterval = null;
    };
    /**
     * Renders the arc onto the SVG element. Proxies `getArc` while setting the proper
     * DOM attribute on the `<path>`.
     */
    CircleProgress.prototype._renderArc = function (currentValue, rotation) {
        // Caches the path reference so it doesn't have to be looked up every time.
        var path = this._path = this._path || this._elementRef.nativeElement.querySelector('path');
        // Ensure that the path was found. This may not be the case if the
        // animation function fires too early.
        if (path) {
            path.setAttribute('d', getSvgArc(currentValue, rotation));
        }
    };
    CircleProgress.decorators = [
        { type: Component, args: [{
                    selector: 'circle-progress',
                    styles: ["\n      :host {\n      display: block;\n      height: 100px;\n      width: 100px;\n      overflow: hidden;\n    }\n    :host svg {\n      height: 100%;\n      width: 100%;\n      -webkit-transform-origin: center;\n              transform-origin: center;\n    }\n    :host path {\n      fill: transparent;\n      stroke-width: 2px;\n      stroke: white;\n    }\n    :host[mode='indeterminate'] svg {\n      -webkit-animation-duration: 5250ms, 2887.5ms;\n              animation-duration: 5250ms, 2887.5ms;\n      -webkit-animation-name: md-progress-circle-sporadic-rotate, md-progress-circle-linear-rotate;\n              animation-name: md-progress-circle-sporadic-rotate, md-progress-circle-linear-rotate;\n      -webkit-animation-timing-function: ease-in-out, linear;\n              animation-timing-function: ease-in-out, linear;\n      -webkit-animation-iteration-count: infinite;\n              animation-iteration-count: infinite;\n      -webkit-transition: none;\n      transition: none;\n    }\n\n    @-webkit-keyframes md-progress-circle-linear-rotate {\n      0% {\n        -webkit-transform: rotate(0deg);\n                transform: rotate(0deg);\n      }\n      100% {\n        -webkit-transform: rotate(360deg);\n                transform: rotate(360deg);\n      }\n    }\n\n    @keyframes md-progress-circle-linear-rotate {\n      0% {\n        -webkit-transform: rotate(0deg);\n                transform: rotate(0deg);\n      }\n      100% {\n        -webkit-transform: rotate(360deg);\n                transform: rotate(360deg);\n      }\n    }\n    @-webkit-keyframes md-progress-circle-sporadic-rotate {\n      12.5% {\n        -webkit-transform: rotate(135deg);\n                transform: rotate(135deg);\n      }\n      25% {\n        -webkit-transform: rotate(270deg);\n                transform: rotate(270deg);\n      }\n      37.5% {\n        -webkit-transform: rotate(405deg);\n                transform: rotate(405deg);\n      }\n      50% {\n        -webkit-transform: rotate(540deg);\n                transform: rotate(540deg);\n      }\n      62.5% {\n        -webkit-transform: rotate(675deg);\n                transform: rotate(675deg);\n      }\n      75% {\n        -webkit-transform: rotate(810deg);\n                transform: rotate(810deg);\n      }\n      87.5% {\n        -webkit-transform: rotate(945deg);\n                transform: rotate(945deg);\n      }\n      100% {\n        -webkit-transform: rotate(1080deg);\n                transform: rotate(1080deg);\n      }\n    }\n    @keyframes md-progress-circle-sporadic-rotate {\n      12.5% {\n        -webkit-transform: rotate(135deg);\n                transform: rotate(135deg);\n      }\n      25% {\n        -webkit-transform: rotate(270deg);\n                transform: rotate(270deg);\n      }\n      37.5% {\n        -webkit-transform: rotate(405deg);\n                transform: rotate(405deg);\n      }\n      50% {\n        -webkit-transform: rotate(540deg);\n                transform: rotate(540deg);\n      }\n      62.5% {\n        -webkit-transform: rotate(675deg);\n                transform: rotate(675deg);\n      }\n      75% {\n        -webkit-transform: rotate(810deg);\n                transform: rotate(810deg);\n      }\n      87.5% {\n        -webkit-transform: rotate(945deg);\n                transform: rotate(945deg);\n      }\n      100% {\n        -webkit-transform: rotate(1080deg);\n                transform: rotate(1080deg);\n      }\n    }"
                    ],
                    template: "\n    <svg viewBox=\"0 0 100 100\"\n         preserveAspectRatio=\"xMidYMid meet\">\n      <path></path>\n    </svg>\n    "
                },] },
    ];
    /** @nocollapse */
    CircleProgress.ctorParameters = [
        { type: ChangeDetectorRef, },
        { type: NgZone, },
        { type: ElementRef, },
    ];
    CircleProgress.propDecorators = {
        'value': [{ type: Input },],
    };
    return CircleProgress;
}());
/**
 * Module functions.
 */
/** Clamps a value to be between 0 and 100. */
function clamp(v) {
    return Math.max(0, Math.min(100, v));
}
/**
 * Converts Polar coordinates to Cartesian.
 */
function polarToCartesian(radius, pathRadius, angleInDegrees) {
    var angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;
    return (radius + (pathRadius * Math.cos(angleInRadians))) +
        ',' + (radius + (pathRadius * Math.sin(angleInRadians)));
}
/**
 * Easing function for linear animation.
 */
function linearEase(currentTime, startValue, changeInValue, duration) {
    return changeInValue * currentTime / duration + startValue;
}
/**
 * Easing function to match material design indeterminate animation.
 */
function materialEase(currentTime, startValue, changeInValue, duration) {
    var time = currentTime / duration;
    var timeCubed = Math.pow(time, 3);
    var timeQuad = Math.pow(time, 4);
    var timeQuint = Math.pow(time, 5);
    return startValue + changeInValue * ((6 * timeQuint) + (-15 * timeQuad) + (10 * timeCubed));
}
/**
 * Determines the path value to define the arc.  Converting percentage values to to polar
 * coordinates on the circle, and then to cartesian coordinates in the viewport.
 *
 * @param currentValue The current percentage value of the progress circle, the percentage of the
 *    circle to fill.
 * @param rotation The starting point of the circle with 0 being the 0 degree point.
 * @return A string for an SVG path representing a circle filled from the starting point to the
 *    percentage value provided.
 */
function getSvgArc(currentValue, rotation) {
    var startPoint = rotation || 0;
    var radius = 50;
    var pathRadius = 40;
    var startAngle = startPoint * MAX_ANGLE;
    var endAngle = currentValue * MAX_ANGLE;
    var start = polarToCartesian(radius, pathRadius, startAngle);
    var end = polarToCartesian(radius, pathRadius, endAngle + startAngle);
    var arcSweep = endAngle < 0 ? 0 : 1;
    var largeArcFlag;
    if (endAngle < 0) {
        largeArcFlag = endAngle >= -180 ? 0 : 1;
    }
    else {
        largeArcFlag = endAngle <= 180 ? 0 : 1;
    }
    return "M" + start + "A" + pathRadius + "," + pathRadius + " 0 " + largeArcFlag + "," + arcSweep + " " + end;
}
//# sourceMappingURL=circle-progress.js.map